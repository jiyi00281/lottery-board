 <!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>波场极速彩 - 智能预测看板</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
</head>
<body>
<div class="container mt-4">
  <h2 class="mb-4">波场极速彩 - 智能预测看板</h2>

  <div id="api-status" class="alert alert-secondary">接口初始化中...</div>

  <div class="alert alert-info">
    <p><strong>预测数字：</strong> <span id="predicted-number">-</span></p>
    <p><strong>命中率估算：</strong> <span id="predicted-accuracy">--</span>%</p>
    <p><strong>使用模型：</strong> <span id="model-used">--</span></p>
    <p><strong>分析说明：</strong> <span id="analysis-desc">--</span></p>
  </div>

  <p class="text-muted">最近开奖时间：<span id="last-updated">--</span></p>
</div>

<script>
const API_URL = 'https://corsproxy.io/?https://api1.duoqu.online/data?code=Tron-Fast&limit=30&key=rkjpugmlzj';
const REFRESH_INTERVAL = 10000;

function predictUsingProbability(data) {
  const counts = Array(10).fill(0);
  data.forEach(item => {
    const numbers = item.openNumber.split(',').map(n => parseInt(n));
    numbers.forEach(n => counts[n]++);
  });
  const maxCount = Math.max(...counts);
  const predictedNumber = counts.indexOf(maxCount);
  return {
    number: predictedNumber,
    accuracy: (maxCount / (data.length * 4) * 100).toFixed(2),
    model: "概率加权模型",
    reason: "概率模型得分更稳定"
  };
}

function predictUsingGenetic(data) {
  const geneCounts = Array(10).fill(0);
  data.forEach(item => {
    const nums = item.openNumber.split(',').map(n => parseInt(n));
    nums.forEach(n => geneCounts[n]++);
  });
  const topGenes = geneCounts.map((val, idx) => ({n: idx, c: val}))
                             .sort((a, b) => b.c - a.c);
  const predicted = topGenes[1].n;
  return {
    number: predicted,
    accuracy: (topGenes[1].c / (data.length * 4) * 100).toFixed(2),
    model: "遗传算法模型",
    reason: "近期历史中出现次数更密集"
  };
}

function autoSelectBestPrediction(data) {
  const prob = predictUsingProbability(data);
  const gene = predictUsingGenetic(data);
  return parseFloat(prob.accuracy) > parseFloat(gene.accuracy) ? prob : gene;
}

async function fetchLotteryData() {
  try {
    const res = await fetch(API_URL);
    const json = await res.json();

    if (!json || !json.data || json.data.length === 0) {
      document.getElementById("api-status").textContent = "接口正常，但未获取到数据";
      return;
    }

    const latest = json.data[0];
    document.getElementById("last-updated").textContent = latest.openTime;
    document.getElementById("api-status").textContent = "数据更新成功";

    const result = autoSelectBestPrediction(json.data);
    document.getElementById("predicted-number").textContent = result.number;
    document.getElementById("predicted-accuracy").textContent = result.accuracy;
    document.getElementById("model-used").textContent = result.model;
    document.getElementById("analysis-desc").textContent = result.reason;
  } catch (err) {
    document.getElementById("api-status").textContent = "接口请求失败：" + err.message;
    console.error("请求错误", err);
  }
}

fetchLotteryData();
setInterval(fetchLotteryData, REFRESH_INTERVAL);
</script>
</body>
</html>
