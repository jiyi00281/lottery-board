<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>波场极速彩 - 智能预测看板</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body { font-family: "Microsoft YaHei", sans-serif; background: #f8f8f8; margin: 0; padding: 20px; }
    .container { max-width: 800px; margin: auto; background: #fff; padding: 20px; border-radius: 10px; }
    .info-box { background: #dff0d8; padding: 10px; margin-bottom: 10px; border-left: 5px solid #3c763d; }
    .result-box { background: #d9f7fb; padding: 15px; border-left: 5px solid #31708f; }
    .label { font-weight: bold; color: #a94442; }
    .value { font-size: 20px; color: #333; }
    .footer { margin-top: 20px; font-size: 12px; color: gray; }
  </style>
</head>
<body>
  <div class="container">
    <div class="info-box" id="status">数据初始化中...</div>

    <div class="result-box">
      <div><span class="label">预测数字：</span><span class="value" id="predicted-number">-</span></div>
      <div><span class="label">命中率估算：</span><span id="estimated-accuracy">--</span>%</div>
      <div><span class="label">使用模型：</span><span id="model-used">--</span></div>
      <div><span class="label">分析说明：</span><span id="model-reason">--</span></div>
    </div>

    <div class="footer">最近开奖时间：<span id="last-open-time">--</span></div>
  </div>

  <script>
    const API_URL = 'https://api1.duoqu.online/data?code=Tron-Fast&limit=30&key=rkjpugmlzj';
    const REFRESH_INTERVAL = 30000;

    async function fetchData() {
      try {
        const res = await fetch(API_URL);
        const json = await res.json();
        if (!json.data || json.data.length === 0) throw new Error("无数据");

        document.getElementById("status").innerText = "数据更新成功";
        const numbers = json.data.map(item => item.openNumber.split(',').map(Number)).flat();
        const lastTime = json.data[0].openTime;
        document.getElementById("last-open-time").innerText = lastTime;

        const counts = Array(10).fill(0);
        numbers.forEach(n => counts[n]++);
        const max = Math.max(...counts);
        const probableNumbers = counts.map((v, i) => ({ num: i, count: v }));

        // 模型选择逻辑
        const useGenetic = Math.random() > 0.5;
        let predicted = -1;
        let model = '';
        let reason = '';

        if (useGenetic) {
          predicted = geneticModel(counts);
          model = '遗传算法模型';
          reason = '适用于多峰值数据分布';
        } else {
          predicted = probabilityModel(counts);
          model = '概率加权模型';
          reason = '频率模型得分更稳定';
        }

        const total = numbers.length;
        const accuracy = ((counts[predicted] / total) * 100).toFixed(2);

        // 展示结果
        document.getElementById("predicted-number").innerText = predicted;
        document.getElementById("estimated-accuracy").innerText = accuracy;
        document.getElementById("model-used").innerText = model;
        document.getElementById("model-reason").innerText = reason;
      } catch (e) {
        document.getElementById("status").innerText = "接口获取失败：" + e.message;
      }
    }

    // 模型：概率分布
    function probabilityModel(counts) {
      let max = Math.max(...counts);
      return counts.findIndex(v => v === max);
    }

    // 模型：遗传算法简化版
    function geneticModel(counts) {
      let population = Array.from({ length: 10 }, (_, i) => i);
      for (let i = 0; i < 3; i++) {
        population.sort((a, b) => counts[b] - counts[a]);
        const top = population.slice(0, 5);
        population = top.concat(
          Array.from({ length: 5 }, () => Math.floor(Math.random() * 10))
        );
      }
      return population[0];
    }

    fetchData();
    setInterval(fetchData, REFRESH_INTERVAL);
  </script>
</body>
</html>
